/*************************************************************************************************************************
*   main.cpp
*   BinarySearchTree
*
*   Created by Zachary Torricelli on 3/18/19.
*   Copyright Â© 2019 Zachary Torricelli. All rights reserved.
*
*   Implement your binary search tree.
*   You must implement all the following functions/ algorithms (in-order tree traversal, search for a particular key in a
*   binary search tree, find the minimum and maximum, find the successor of a given node x [must test both the
*   situations], insert a new key, delete a key [must test all the situations]) for binary search trees
*
*************************************************************************************************************************/

#include <iostream>
#include <iomanip>
#define SIZE 11

using namespace std;


// Struct used to create a node
struct node
{
    
    int data;
    node *leftChild;
    node *rightChild;
    node *parent;
    
};


// Global variable
//node *root = NULL;


// Function prototypes
node *newNode(int);
node *insert(node*, int);
node *minimumValue(node*);
node *maximumValue(node*);
node *search(node*, int);
node *successor(node*);
void printTreeInOrder(node*);



// Main driver function
int main()
{
    
    // Variable declaration in the main function
    int myArray[SIZE] = { 15, 6, 18, 3, 7, 17, 20, 2, 4, 13, 9 };
    int choice = 8;
    int insertValue = 0;
    int searchValue = 0;
    node *root = NULL;
    node *goal;
    node *success;
    
    
    // Displays a welcome message to the console
    cout << "Welcome to Zac's Binary Search Tree!" << endl;
    cout << "Please enter a number (1-7)." << endl << endl;
    
    root = insert(root, 15);
    insert(root, 6);
    insert(root, 18);
    insert(root, 3);
    insert(root, 7);
    insert(root, 17);
    insert(root, 20);
    insert(root, 2);
    insert(root, 4);
    insert(root, 13);
    insert(root, 9);
    
    
    do
    {
        
        // Displays a menu to the console
        cout << "1. View Binary Tree " << endl;
        cout << "2. Insert New Key" << endl;
        cout << "3. Find Minimum and Maximum Value" << endl;
        cout << "4. Search Tree" << endl;
        cout << "5. View Successor" << endl;
        cout << "6. Print Tree In Order" << endl;
        cout << "7. Delete Key" << endl;
        cout << "8. Exit" << endl << endl;
        
        
        cin >> choice;
        
        
        // Makes sure the user inputs a valid option
        while (cin.fail())
        {
            
            cin.clear();
            cin.ignore(numeric_limits<streamsize>::max(), '\n');
            cout << endl << "Please enter a number (1-7)." << endl << endl;
            cin >> choice;
            
        }
        
        
        switch (choice)
        {
                
                // Case 1 will perform initialize and print the current BST
            case 1:
                
                system("CLS");
                
                cout << "Current Binary Tree Elements: " << endl;
                
                for(int i = 0; i < SIZE; i++)
                {
                    
                    cout << myArray[i] << "\t";
                    
                }
                
                cout << endl << endl;
                
                
                break;
                
                
                // Case 2 will allow the user to insert a new key
            case 2:
                
                system("CLS");
                
                cout << "What value would you like to insert? " << endl;
                cin >> insertValue;
                cout << endl << endl;
                
                insert(root, insertValue);
                
                
                break;
                
                
                // Case 3 will find the minimum and maximum value in the BST1
            case 3:
                
                system("CLS");
                
                cout << "The minimum value is: " << minimumValue(root)->data << endl << endl;
                cout << "The maximum value is: " << maximumValue(root)->data << endl << endl;
                
                
                break;
                
                // Case 4 will perform a Search of the Tree
            case 4:
                
                system("CLS");
                
                cout << "What value would you like to search for? " << endl;
                cin >> searchValue;
                cout << endl << endl;
                
                
                goal = search(root, searchValue);
                
                if(goal)
                {
                    
                    cout << "Search Key Found: " << goal->data << endl;
                    
                }
                
                else
                {
                    
                    cout << "Search Key Not Found" << endl;
                    
                }
                
                cout << endl << endl;
                
                break;
                
                
                // Case 5 will print the successors
            case 5:
                
                system("CLS");
                
                cout << "Successor of the root is: ";
                cout << successor(root)->data << endl << endl;
                
                //cout << "Successor of the Minimum Value is: ";
                //minSucc = (successor(minimumValue(root)));
               // cout << minSucc->data << endl << endl;
                
                success = successor(maximumValue(root));
                
                if(success != NULL)
                {
                    
                    cout << "Successor is: " << success->data << endl << endl;
                    
                }
                
                else
                {
                    
                    cout << "No Successor of the Maximum Value" << endl << endl;
                    
                }
                
                cout << endl << endl;
                
                
                break;
                
                
                // Case 6 will print the BST in order
            case 6:
                
                system("CLS");
                
                cout << "Binary Tree In Order: " << endl;
                
                printTreeInOrder(root);
                
                cout << endl << endl;
                

                break;
                
                
                // Case 7 will delete a key
            case 7:
                
                break;
                
                
                // Case 8 will exit the program
            case 8:
                
                exit(0);
                
                
                // Default case will collect the invalid options input and let the user try again
            default:
                
                system("CLS");
                cout << "Invalid selection. Try again" << endl;
                
        }
        
    } while (choice != 7);
    
    
    
    return 0;
    
}



// Function used to create a new node
node *newNode(int data)
{
    
    // Creates a new node
    struct node *temp =  (struct node *)malloc(sizeof(struct node));
    
    temp->data = data;
    
    temp->leftChild = temp->rightChild = NULL;
    
    // Returns the new node
    return temp;
    
}


// Function to insert a new node in the binary search tree
node *insert(node* node, int data)
{
    
    if(node == NULL)
    {
        
        return newNode(data);
        
    }
    
    
    if(data < node->data)
    {
        
        struct node *tempL = insert(node->leftChild, data);
        node->leftChild = tempL;
        
    }
    
    else if(data > node->data)
    {
        
        struct node *tempR = insert(node->rightChild, data);
        node->rightChild = tempR;
        
        tempR->parent = node;
        
    }
   
    return node;

}



// Function used to find the minimum node value in the binary tree
node *minimumValue(node *node)
{
    
    // Node declaraton
    struct node *current = node;
    
    // While loop to search down to find the leftmost leaf
    while (current->leftChild != NULL)
    {
        
        current = current->leftChild;
        
    }
    
    // Returns the minimum value
    return current;
    
}



// Function used to find the maximum value in the binary tree
node *maximumValue(node *node)
{
    
    // Node declaraton
    struct node *current = node;
    
    // While loop to search down to find the leftmost leaf
    while (current->rightChild != NULL)
    {
        
        current = current->rightChild;
        
    }
    
    // Returns the minimum value
    return current;
    
}



// Function used to search for a particular value in the binary search tree
node *search(node* node, int data)
{
    
    
    if (node == NULL || node->data == data)
    {
        
        return node;
        
    }
    
    
    if (node->data < data)
    {
        
        return search(node->rightChild, data);
        
    }
    
    
    return search(node->leftChild, data);
    
}



// Function used to returnn the successor of a node in a BST
node *successor(node* node)
{
    
    if (node->rightChild != NULL)
    {
        
        return minimumValue(node->rightChild);
        
    }
    
    struct node *temp;
    temp = node->parent;
    
    while(temp != NULL && node == temp->rightChild)
    {
        
        node = temp;
        temp = temp->parent;
        
    }
    
    return temp;
    
}



// Recursive function used to print the binary tree in order
void printTreeInOrder(node *node)
{
    
    if (node != NULL)
    {
        
        printTreeInOrder(node->leftChild);
        
        cout << node->data << "\t";
        
        printTreeInOrder(node->rightChild);
        
    }
    
}



